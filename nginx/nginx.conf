# Mode déterminé par la variable d'environnement NODE_ENV (dev/production)
user nginx;
worker_processes auto;
error_log /var/log/nginx/error.log notice;
pid /var/run/nginx.pid;

events { 
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types; 
    default_type application/octet-stream; 

    # Configuration de logging
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';
    access_log /var/log/nginx/access.log main;

    # Optimisations
    sendfile on; 
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 20M;

    # Compression
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml text/javascript 
               application/json application/javascript application/xml+rss 
               application/rss+xml font/truetype font/opentype 
               application/vnd.ms-fontobject image/svg+xml;

    # ============ UPSTREAMS ============
    # Backend PHP-FPM (identique en dev et prod)
    upstream intranet_backend_service {
        least_conn;
        server intranet-backend:9000;
        keepalive 8;
    }

    # ============ REDIRECTION HTTP → HTTPS ============
    server {
        listen 80;
        # Le server_name est défini via la variable d'environnement SERVER_NAME dans le fichier .env
        # Par défaut : localhost (dev) | En production : définir SERVER_NAME=intranet.com 10.168.1.26
        server_name ${SERVER_NAME};
        
        # Redirection forcée vers HTTPS
        # En production avec port 443 standard : return 301 https://$server_name$request_uri;
        # En dev avec port 8443 : return 301 https://$server_name:8443$request_uri;
        return 301 https://$server_name$request_uri;
    }

    # ============ SERVEUR PRINCIPAL HTTPS ============
    server {
        listen 443 ssl;
        http2 on;
        # Le server_name est défini via la variable d'environnement SERVER_NAME dans le fichier .env
        # Par défaut : localhost (dev) | En production : définir SERVER_NAME=intranet.com 10.168.1.26
        server_name ${SERVER_NAME};

        # Résolveur DNS Docker pour permettre le démarrage même si le frontend n'est pas prêt
        resolver 127.0.0.11 valid=30s;

        # Configuration SSL
        ssl_certificate /etc/nginx/ssl/certificate.crt;
        ssl_certificate_key /etc/nginx/ssl/private.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA256;
        ssl_prefer_server_ciphers off;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;

        # Headers de sécurité
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Strict-Transport-Security "max-age=63072000; includeSubDomains" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;


        # ============ API ROUTES (Laravel Backend) ============
        location /api/ {
            # Utilisation de FastCGI pour PHP-FPM
            fastcgi_pass intranet_backend_service;
            fastcgi_index index.php;
            fastcgi_param SCRIPT_FILENAME /var/www/html/public/index.php;
            include fastcgi_params;
            
            # Variables FastCGI spécifiques
            fastcgi_param REQUEST_URI $request_uri;
            fastcgi_param QUERY_STRING $query_string;
            fastcgi_param REQUEST_METHOD $request_method;
            fastcgi_param CONTENT_TYPE $content_type;
            fastcgi_param CONTENT_LENGTH $content_length;
            
            # Headers personnalisés
            fastcgi_param HTTP_HOST $host;
            fastcgi_param HTTP_X_REAL_IP $remote_addr;
            fastcgi_param HTTP_X_FORWARDED_FOR $proxy_add_x_forwarded_for;
            fastcgi_param HTTP_X_FORWARDED_PROTO $scheme;
            fastcgi_param HTTPS on;
            
            # Buffers pour FastCGI
            fastcgi_buffer_size 32k;
            fastcgi_buffers 8 16k;
            fastcgi_busy_buffers_size 64k;
            fastcgi_temp_file_write_size 64k;
            
            # Timeouts
            fastcgi_connect_timeout 60s;
            fastcgi_send_timeout 60s;
            fastcgi_read_timeout 60s;
        }

        # ============ STORAGE FILES (Laravel) ============
        # Servir les fichiers statiques uploadés via Laravel
        location /storage/ {
            alias /var/www/intranet-backend/storage/app/public/;
            expires 30d;
            add_header Cache-Control "public, immutable";
            
            # Essayer de servir le fichier, sinon 404
            try_files $uri =404;
            
            # Types de fichiers autorisés (sécurité)
            location ~* \.(jpg|jpeg|png|gif|ico|svg|webp|pdf|doc|docx|xls|xlsx)$ {
                add_header Cache-Control "public, max-age=2592000";
            }
        }

        # ============ FRONTEND ============
        # La configuration change selon l'environnement (dev vs production)
        
        # MODE DÉVELOPPEMENT : Vite Dev Server avec Hot Reload
        # WebSocket pour Vite HMR
        location /@vite/client {
            set $vite_upstream http://intranet-frontend:5173;
            proxy_pass $vite_upstream;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_cache_bypass $http_upgrade;
            proxy_read_timeout 86400;
        }

        # Assets Vite en mode dev (fichiers .js, .css, etc.)
        location ~ ^/(src|node_modules|@fs|@id)/ {
            set $vite_upstream http://intranet-frontend:5173;
            proxy_pass $vite_upstream;
            include /etc/nginx/proxy_params.conf;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
        }

        # MODE PRODUCTION : Fichiers statiques buildés
        # Servir les assets statiques (JS, CSS, images, fonts)
        location /assets/ {
            alias /var/www/intranet-frontend/dist/assets/;
            expires 1y;
            add_header Cache-Control "public, immutable";
            
            # Compression des fichiers statiques
            gzip_static on;
            try_files $uri =404;
        }

        # Fichiers statiques à la racine (favicon, robots.txt, etc.)
        location ~* ^/(favicon\.ico|robots\.txt|vite\.svg)$ {
            root /var/www/intranet-frontend/dist;
            expires 30d;
            add_header Cache-Control "public";
            try_files $uri =404;
        }

        # Route principale - Comportement adaptatif selon l'environnement
        location / {
            # En développement : proxy vers Vite dev server
            # En production : servir les fichiers statiques buildés
            
            # Vérifier si index.html existe (mode production)
            # Sinon, passer directement au serveur Vite dev
            root /var/www/intranet-frontend/dist;
            
            # Essayer le fichier, puis le répertoire avec index, puis le fallback Vite
            # Note: Le = empeche le directory listing et force le fallback
            error_page 404 403 = @vite_dev_server;
            try_files $uri $uri/ /index.html @vite_dev_server;
        }

        # Fallback : proxy vers Vite dev server (mode dev)
        location @vite_dev_server {
            set $vite_upstream http://intranet-frontend:5173;
            proxy_pass $vite_upstream;
            include /etc/nginx/proxy_params.conf;
            
            # Support pour le Hot Module Replacement (HMR)
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "upgrade";
            proxy_cache_bypass $http_upgrade;
        }

        # ============ HEALTH CHECK ============
        location /health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }
    }
}